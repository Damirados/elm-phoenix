module Phoenix.Socket
  ( Socket
  , Transport(..)
  , Logger(..), LogMessage
  , Status(..)
  , Response(..)
  , socket, transport, heartbeatIntervalMs, reconnectAfterMs
  , logger, longpollerTimeout, params, onStateChange, updateParams
  , connect, tryConnect, disconnect
  , toString
  ) where

{-| Elm adapter for Phoenix Channels transport layer

## Prerequisites

Make sure your Phoenix main app (`app.js`) imports Socket from `phoenix.js`,
and makes it available through Window.Phoenix.Socket. Do the same for
LongPoll if you intend to specify the `LongPoll` socket tranport option.

```JavaScript
import {Socket, LongPoll} from "deps/phoenix/web/static/js/phoenix"

window.Phoenix = window.Phoenix || {}
window.Phoenix.Socket = window.Phoenix.Socket || Socket
window.Phoenix.LongPoll = window.Phoenix.LongPoll || LongPoll
```

Now just embed your Elm app into the right HTML tag generated by your Phoenix
app's layout/template:

```JavaScript
let myApp = Elm.embed(
  Elm.MyApp,
  document.getElementById("elm-main"),
  {}
);
```

## Socket configuration

@docs socket
@docs Transport, transport
@docs heartbeatIntervalMs
@docs reconnectAfterMs
@docs Logger, LogMessage, logger
@docs longpollerTimeout
@docs params

## Hooks

@docs Status, Response, onStateChange

## Socket management

@docs Socket, connect, tryConnect
@docs updateParams
@docs disconnect

## Other

@docs toString
-}


import Task exposing (Task)
import Json.Decode
import Native.Phoenix

{-| Opaque type representing the connecting with the server.
-}

type Socket = Socket


{-| Phoenix socket transport:

* Auto - use WebSocket if supported by the browser, LongPoll otherwise
* WebSocket - use WebSocket client (requires compatible browser)
* LongPoll - use the Phoenix LongPoll client
-}

type Transport
  = Auto
  | WebSocket
  | LongPoll


{-| A log message reported by the phoenix.js library.
-}

type alias LogMessage =
  { kind: String
  , message: String
  , data: Maybe Json.Decode.Value
  }


{-| The destination for log messages:

* `Console` means logging directly to the JavaScript console
* The `Mailbox` option specifies a mailbox for delivering log messages in
`LogMessage` format to the Elm application
-}

type Logger
  = Console
  | Mailbox (Signal.Address LogMessage)


{-| The current status of the `Socket` connection. In case of
`Closed` or `Error`, the JavaScript event that triggered the status
is included as a JSON value.
-}

type Status
  = Unknown
  | Open
  | Closed Json.Decode.Value
  | Error Json.Decode.Value


{-| Possible return values for the `onStateChange` callback:

* `Ignore` - do nothing
* `Disconnect` - close the socket and do not attempt to reconnect
* `SendMessage`: send the given message to the Elm application
* `PerformTask` - perform the secified task
-}

type Response x a
  = Ignore
  | Disconnect
  | SendMessage Signal.Message
  | PerformTask (Task x a)


type alias StateChangeCallback x a =
  Status -> Response x a


type alias Options x a =
  { endPoint: String
  , transport: Transport
  , heartbeatIntervalMs: Maybe Int
  , reconnectAfterMs: (List Int)
  , logger: Maybe Logger
  , longpollerTimeout: Maybe Int
  , params: Maybe Json.Decode.Value
  , onStateChange: Maybe (StateChangeCallback x a)
  }


{-| Create a basic Phoenix socket configuration for the given endpoint.
The endpoint may be specified as a relative path or an absolute ws/wss URL.

The following default settings may be changed using the functions in this
module before calling `connect`:

* transport: Auto - use WebSockets if available, fall back to LongPoll
* heartbeatIntervalMs: Nothing - phoenix.js default
* reconnectAfterMs: [] - phoenix.js default
* logger: Nothing - logging disabled
* longpollerTimeout: Nothing - phoenix.js default
* params: [] - no parameters passed to Phoenix
* onStateChange: Nothing - no state change notifications
-}

socket : String -> Options x a
socket endPoint =
  Options endPoint Auto Nothing [] Nothing Nothing Nothing Nothing


{-| Select the socket transport protocol to use.
-}

transport : Transport -> Options x a -> Options x a
transport transport options =
  { options
    | transport = transport
  }


{-| Specify the heartbeat interval (in milliseconds).
-}

heartbeatIntervalMs : Int -> Options x a -> Options x a
heartbeatIntervalMs interval options =
  { options
    | heartbeatIntervalMs = Just interval
  }


{-| Specify the intervals at which to attempt to reconnect a broken
socket. This should be a list of intervals (in milliseconds) that
increase exponentially. The last value in the list is the maximum that
will be used until the connection is actually re-established.

Example: [1000, 2000, 4000, 8000, 16000]
-}

reconnectAfterMs : List Int -> Options x a -> Options x a
reconnectAfterMs intervals options =
  { options
    | reconnectAfterMs = intervals
  }

{-| Enable phoenix.js logging, either to the JavaScript console or
the Elm application.
-}

logger : Logger -> Options x a -> Options x a
logger destination options =
  { options
    | logger = Just destination
  }


{-| The maximum timeout of a long poll AJAX request (in milliseconds).
-}

longpollerTimeout : Int -> Options x a -> Options x a
longpollerTimeout timeout options =
  { options
    | longpollerTimeout = Just timeout
  }

{-| The (initial) parameters to send to the server during connection
establishment.
-}

params : Json.Decode.Value -> Options x a -> Options x a
params params options =
  { options
    | params = Just params
  }


{-| Enable state change notification. From the moment the `connect` function
is called, for the lifetime of the socket, any state changes will trigger
the specified callback, passing in the latest socket status.
-}

onStateChange : StateChangeCallback x a -> Options x a -> Options x a
onStateChange callback options =
  { options
    | onStateChange = Just callback
  }


{-| Trigger the connection to the server. Returns a `Task` that always
succeeds immediately with a `Socket` handle. The application will be notified
about success or failure through the `onStateChange` hook, if enabled.
If the connection cannot be established initially or it is lost at a later
point in time, attempts will be made to re-establish the connection
automatically.
-}

connect : Options x a -> Task x Socket
connect =
  Native.Phoenix.connect


{-| Attempt to connect to the server. Returns a `Task` that succeeds with a
socket handle once the connection has been established, with automatic
connection re-establishment as described under `connect`. If the attempt
fails, the `Task` fails with an error message, and no further attempts are
made to connect to the server.

TODO: determine the reason for failure and return a more useful error type
(e.g. in response to 404, 401, 500, ...)
-}

tryConnect : Options x a -> Task Json.Decode.Value Socket
tryConnect =
  Native.Phoenix.tryConnect


{-| Update the parameters to send to the server. The new values will be
use when trying to re-establish a broken connection. Returns a task that
always succeeds.
-}

updateParams : Json.Decode.Value -> Socket -> Task x ()
updateParams =
  Native.Phoenix.updateParams


{-| Close the connection with the server and do not attempt to reconnect.
-}

disconnect : Socket -> Task x ()
disconnect =
  Native.Phoenix.disconnect


{-| Return a printable representation of the socket. Useful for logging
or debugging, since the native `phoenix.js` objects have circular references
that cause stack overflows in Elm's `toString`.
-}

toString : Socket -> String
toString =
  Native.Phoenix.socketToString
